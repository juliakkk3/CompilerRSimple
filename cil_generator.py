"""
Генератор CIL-коду для віртуальної машини CLR (.NET)
CIL = Common Intermediate Language (проміжна мова .NET)
"""

class CILGenerator:
    """Генератор CIL-коду з постфіксної нотації"""

    def __init__(self, postfix_code, variable_table, assembly_name="test1"):
        """
        Ініціалізація генератора

        Args:
            postfix_code: список інструкцій у постфіксній нотації
            variable_table: таблиця змінних {ім'я: (індекс, тип, ініціалізована)}
            assembly_name: ім'я збірки (без розширення .exe)
        """
        # Зберігаємо вхідні дані
        self.postfix_code = postfix_code
        # Таблиця змінних для генерації .locals
        self.variable_table = variable_table
        # Ім'я збірки (буде використано в .assembly та .module)
        self.assembly_name = assembly_name
        # Масив для збору згенерованих рядків CIL-коду
        self.cil_code = []
        # Відображення міток постфіксу на позиції в CIL (для переходів)
        self.label_mapping = {}

    def generate(self):
        """
        Генерує повний CIL-код

        Returns:
            str: готовий CIL-код для запису у .il файл
        """
        # Генерація заголовка .il файлу
        self._generate_header()
        # Генерація визначення класу Program
        self._generate_class_definition()
        # Генерація методу Main з інструкціями
        self._generate_main_method()
        # Об'єднуємо всі рядки в один текст через перенос рядка
        return '\n'.join(self.cil_code)

    def _generate_header(self):
        """Генерує заголовок .il файлу (посилання на mscorlib, визначення збірки)"""
        # Додаємо коментар про походження файлу
        self.cil_code.extend([
            "// Generated by RSimple Compiler",
            "",  # Порожній рядок для читабельності
            # Посилання на стандартну бібліотеку .NET
            ".assembly extern mscorlib",
            "{",
            # Public key token для mscorlib (стандартний для .NET 4.0)
            "  .publickeytoken = (B7 7A 5C 56 19 34 E0 89 )",
            # Версія mscorlib (4.0.0.0 для .NET Framework 4.0)
            "  .ver 4:0:0:0",
            "}",
            "",  # Порожній рядок
            # Визначення нашої збірки
            f".assembly {self.assembly_name}",
            "{",
            # Алгоритм хешування (SHA1)
            "  .hash algorithm 0x00008004",
            # Версія нашої збірки
            "  .ver 0:0:0:0",
            "}",
            # Визначення модуля (виконуваного файлу)
            f".module {self.assembly_name}.exe",
            ""  # Порожній рядок
        ])

    def _generate_class_definition(self):
        """Генерує визначення класу Program"""
        # Клас Program наслідується від System.Object
        self.cil_code.extend([
            # private - клас приватний
            # auto - автоматичне розташування полів
            # ansi - ANSI string marshaling
            # beforefieldinit - оптимізація ініціалізації статичних полів
            ".class private auto ansi beforefieldinit Program",
            # Наслідування від базового класу Object
            "  extends [mscorlib]System.Object",
            "{"  # Початок тіла класу
        ])

    def _generate_main_method(self):
        """Генерує метод Main з CIL-інструкціями"""
        # Сигнатура методу Main
        self.cil_code.extend([
            # private - приватний метод
            # hidebysig - приховує методи базового класу з такою ж сигнатурою
            # static - статичний метод
            # void - не повертає значення
            # Main(string[] args) - стандартна точка входу
            # cil managed - керований код CIL
            "  .method private hidebysig static void Main(string[] args) cil managed",
            "  {",  # Початок тіла методу
        ])

        # Генерація оголошення локальних змінних
        self._generate_locals()

        # Додаткові директиви методу
        self.cil_code.extend([
            # .entrypoint - позначає цей метод як точку входу в програму
            "    .entrypoint",
            # .maxstack 8 - максимальний розмір стеку оцінки (8 достатньо для більшості операцій)
            "    .maxstack 8",
            ""  # Порожній рядок перед інструкціями
        ])

        # Генерація CIL-інструкцій з постфікс-коду
        self._generate_instructions()

        # Завершення методу та класу
        self.cil_code.extend([
            # ret - повернення з методу
            "    ret",
            "  }",  # Кінець методу Main
            "}"     # Кінець класу Program
        ])

    def _generate_locals(self):
        """Генерує оголошення локальних змінних"""
        # Якщо немає змінних, не генеруємо секцію .locals
        if not self.variable_table:
            return

        # Початок секції локальних змінних
        # .locals init - ініціалізує змінні нулями
        self.cil_code.append("    .locals init (")

        # Сортуємо змінні за індексом для правильного порядку
        sorted_vars = sorted(self.variable_table.items(),
                           key=lambda x: x[1][0])

        # Генеруємо оголошення кожної змінної
        for i, (ident, (index, var_type, _)) in enumerate(sorted_vars):
            # Конвертуємо тип RSimple в тип CIL
            cil_type = self._convert_type_to_cil(var_type)
            # Робимо ім'я безпечним (якщо це ключове слово CIL)
            safe_ident = self._make_safe_identifier(ident)
            # Формуємо рядок оголошення: [індекс] тип ім'я
            line = f"      [{index-1}] {cil_type} {safe_ident}"

            # Додаємо кому після всіх змінних крім останньої
            if i < len(sorted_vars) - 1:
                line += ","

            # Додаємо рядок до коду
            self.cil_code.append(line)

        # Закриваємо секцію .locals
        self.cil_code.append("    )")

    def _make_safe_identifier(self, ident):
        """
        Робить ідентифікатор безпечним для CIL (уникає ключових слів)

        Args:
            ident: оригінальне ім'я змінної

        Returns:
            str: безпечне ім'я (з префіксом var_ якщо потрібно)
        """
        # Список зарезервованих ключових слів CIL та .NET
        cil_keywords = {
            # CIL інструкції
            'add', 'and', 'box', 'br', 'break', 'call', 'callvirt', 'ceq', 'cgt', 'clt',
            'conv', 'div', 'dup', 'ldarg', 'ldloc', 'ldstr', 'ldc', 'mul', 'neg', 'newarr',
            'not', 'or', 'pop', 'ret', 'starg', 'stloc', 'sub', 'throw', 'xor',
            # Оголошення та модифікатори
            'class', 'method', 'field', 'property', 'event', 'interface', 'enum',
            'value', 'object', 'string', 'void', 'bool', 'char', 'int8', 'int16',
            'int32', 'int64', 'float32', 'float64', 'unsigned', 'native',
            'final', 'virtual', 'abstract', 'static', 'public', 'private', 'protected',
            'internal', 'extern', 'override', 'sealed', 'new', 'base', 'this',
            # Інші .NET ключові слова
            'any', 'as', 'assembly', 'at', 'auto', 'beforefieldinit', 'cil',
            'default', 'extends', 'implements', 'init', 'instance', 'literal',
            'managed', 'module', 'namespace', 'nested', 'pinned', 'request',
            'runtime', 'sequential', 'serializable', 'specialname', 'unmanaged',
            'valuetype', 'vararg'
        }

        # Перевіряємо чи ідентифікатор є ключовим словом (без урахування регістру)
        if ident.lower() in cil_keywords:
            # Додаємо префікс var_ щоб уникнути конфлікту
            return f"var_{ident}"
        # Повертаємо оригінальне ім'я якщо воно безпечне
        return ident

    def _convert_type_to_cil(self, var_type):
        """
        Конвертує тип RSimple в тип CIL

        Args:
            var_type: тип змінної в RSimple ('numeric', 'logical', 'int', 'float')

        Returns:
            str: відповідний тип CIL
        """
        # Таблиця відповідності типів
        type_mapping = {
            'numeric': 'float32',   # Числовий тип → 32-бітне дробове
            'logical': 'int32',     # Логічний тип → 32-бітне ціле (0 або 1)
            'int': 'int32',         # Цілий тип → 32-бітне ціле
            'float': 'float32'      # Дробовий тип → 32-бітне дробове
        }
        # Повертаємо відповідний тип, за замовчуванням float32
        return type_mapping.get(var_type, 'float32')

    def _generate_instructions(self):
        """Генерує CIL-інструкції з постфікс-коду"""
        # Перший прохід: збираємо інформацію про мітки
        self._collect_labels()

        # Другий прохід: генерація інструкцій
        # Лічильник для проходу по постфікс-коду
        i = 0
        while i < len(self.postfix_code):
            # Беремо поточний елемент
            item = self.postfix_code[i]

            # Перевіряємо чи це рядок
            if isinstance(item, str):
                # Перевіряємо чи це мітка (закінчується на ':')
                if item.endswith(':'):
                    # Видаляємо ':' щоб отримати ім'я мітки
                    label_name = item[:-1]
                    # Додаємо мітку в CIL-код
                    self.cil_code.append(f"    {label_name}:")
                else:
                    # Це інструкція - генеруємо відповідний CIL-код
                    # Передаємо індекс для обробки JF/JMP
                    self._generate_instruction(item, i)

            # Переходимо до наступного елемента
            i += 1

    def _collect_labels(self):
        """Збирає інформацію про мітки (перший прохід)"""
        # Лічильник інструкцій (не міток)
        instruction_count = 0
        # Проходимо по всьому постфікс-коду
        for item in self.postfix_code:
            # Перевіряємо чи це мітка
            if isinstance(item, str) and item.endswith(':'):
                # Видаляємо ':' щоб отримати ім'я мітки
                label_name = item[:-1]
                # Зберігаємо позицію мітки
                self.label_mapping[label_name] = instruction_count
            else:
                # Це інструкція, збільшуємо лічильник
                instruction_count += 1

    def _generate_instruction(self, instr, index=0):
        """
        Генерує одну CIL-інструкцію з постфікс-інструкції

        Args:
            instr: постфікс-інструкція (число, змінна, оператор тощо)
            index: індекс інструкції в постфікс-коді (для JF/JMP)
        """

        # ========== ЧИСЛОВІ КОНСТАНТИ ==========
        if self._is_number(instr):
            # Перевіряємо чи це дробове число
            if '.' in instr:
                # Завантажити дробову константу на стек
                # ldc.r4 = load constant real 4-byte (float32)
                self.cil_code.append(f"    ldc.r4 {instr}")
            else:
                # Це ціле число
                value = int(instr)
                # Оптимізація для малих чисел
                if -1 <= value <= 8:
                    # ldc.i4.0, ldc.i4.1, ... ldc.i4.8, ldc.i4.m1 (-1)
                    # Коротша форма для чисел від -1 до 8
                    self.cil_code.append(f"    ldc.i4.{value}" if value >= 0 else f"    ldc.i4.m1")
                elif -128 <= value <= 127:
                    # ldc.i4.s = load constant int32 short form (1 байт)
                    # Для чисел від -128 до 127
                    self.cil_code.append(f"    ldc.i4.s {value}")
                else:
                    # ldc.i4 = load constant int32 (повна форма, 4 байти)
                    self.cil_code.append(f"    ldc.i4 {value}")
                # ВАЖЛИВО: конвертуємо int32 → float32
                # conv.r4 = convert to float32
                # Потрібно бо всі числа в RSimple - float
                self.cil_code.append(f"    conv.r4")

        # ========== БУЛЕВІ КОНСТАНТИ ==========
        elif instr in ('TRUE', 'FALSE'):
            # TRUE → 1, FALSE → 0
            value = '1' if instr == 'TRUE' else '0'
            # Завантажити 0 або 1 на стек
            self.cil_code.append(f"    ldc.i4.{value}")

        # ========== ЗМІННІ (завантаження значення) ==========
        elif instr in self.variable_table:
            # Отримуємо індекс змінної (віднімаємо 1, бо індекси в CIL з 0)
            var_index = self.variable_table[instr][0] - 1
            # Отримуємо тип змінної
            var_type = self.variable_table[instr][1]
            # Робимо ім'я безпечним
            safe_ident = self._make_safe_identifier(instr)

            # ldloc = load local variable (завантажити локальну змінну)
            # Використовуємо короткі форми для перших 4 змінних
            if var_index <= 3:
                # ldloc.0, ldloc.1, ldloc.2, ldloc.3 (коротша форма)
                self.cil_code.append(f"    ldloc.{var_index}")
            else:
                # ldloc N (повна форма для індексів >= 4)
                self.cil_code.append(f"    ldloc {var_index}")

        # ========== МІТКИ ДЛЯ ПЕРЕХОДІВ ==========
        elif instr.startswith('m') and instr[1:].isdigit():
            # Це мітка для JMP/JF (наприклад, "m1", "m2")
            # Не генеруємо код, мітки обробляються окремо
            pass

        # ========== ПРИСВОЮВАННЯ ==========
        elif instr.startswith('='):
            # Видаляємо '=' щоб отримати ім'я змінної
            var_name = instr[1:]
            # Отримуємо індекс змінної
            var_index = self.variable_table[var_name][0] - 1
            # Отримуємо тип змінної
            var_type = self.variable_table[var_name][1]

            # stloc = store local variable (зберегти в локальну змінну)
            # Береже верхній елемент стеку в змінну
            if var_index <= 3:
                # stloc.0, stloc.1, stloc.2, stloc.3 (коротша форма)
                self.cil_code.append(f"    stloc.{var_index}")
            else:
                # stloc N (повна форма)
                self.cil_code.append(f"    stloc {var_index}")

        # ========== АРИФМЕТИЧНІ ОПЕРАЦІЇ ==========
        elif instr == '+':
            # add = додавання (бере 2 значення зі стеку, кладе результат)
            self.cil_code.append("    add")
        elif instr == '-':
            # sub = віднімання
            self.cil_code.append("    sub")
        elif instr == '*':
            # mul = множення
            self.cil_code.append("    mul")
        elif instr == '/':
            # div = ділення
            self.cil_code.append("    div")
        elif instr == '^':
            # Для степеня використовуємо Math.Pow(base, exponent)
            # На стеку: [основа(float32), показник(float32)]
            # Math.Pow приймає: (float64, float64)
            # CLR автоматично конвертує float32 → float64 при виклику!
            self.cil_code.extend([
                # call = виклик статичного методу Math.Pow
                "    call float64 [mscorlib]System.Math::Pow(float64, float64)",
                # conv.r4 = конвертуємо результат float64 назад у float32
                "    conv.r4"
            ])
        elif instr == 'unary-':
            # neg = унарний мінус (змінює знак числа на стеку)
            self.cil_code.append("    neg")

        # ========== ОПЕРАТОРИ ПОРІВНЯННЯ ==========
        elif instr == '<':
            # clt = compare less than (a < b → 1, інакше → 0)
            self.cil_code.append("    clt")
        elif instr == '>':
            # cgt = compare greater than (a > b → 1, інакше → 0)
            self.cil_code.append("    cgt")
        elif instr == '<=':
            # a <= b еквівалентно !(a > b)
            self.cil_code.extend([
                "    cgt",      # a > b
                "    ldc.i4.0", # завантажити 0
                "    ceq"       # (a > b) == 0, тобто a <= b
            ])
        elif instr == '>=':
            # a >= b еквівалентно !(a < b)
            self.cil_code.extend([
                "    clt",      # a < b
                "    ldc.i4.0", # завантажити 0
                "    ceq"       # (a < b) == 0, тобто a >= b
            ])
        elif instr == '==':
            # ceq = compare equal (a == b → 1, інакше → 0)
            self.cil_code.append("    ceq")
        elif instr == '!=':
            # a != b еквівалентно !(a == b)
            self.cil_code.extend([
                "    ceq",      # a == b
                "    ldc.i4.0", # завантажити 0
                "    ceq"       # (a == b) == 0, тобто a != b
            ])

        # ========== ПЕРЕХОДИ (JUMP) ==========
        elif instr == 'JF':
            # JF = Jump if False (перехід якщо умова хибна)
            # Отримуємо мітку перед JF
            label = self._get_label_before(index)
            # brfalse = branch if false (перехід якщо 0 на стеку)
            self.cil_code.append(f"    brfalse {label}")

        elif instr == 'JMP':
            # JMP = Jump (безумовний перехід)
            # Отримуємо мітку перед JMP
            label = self._get_label_before(index)
            # br = branch (безумовний перехід)
            self.cil_code.append(f"    br {label}")

        # ========== ВВЕДЕННЯ-ВИВЕДЕННЯ ==========
        elif instr == 'print':
            # Виведення значення зі стеку
            self._generate_print_instruction()

        elif instr == 'scan':
            # Введення з клавіатури
            self.cil_code.extend([
                # Console.ReadLine() - читає рядок з консолі
                "    call string [mscorlib]System.Console::ReadLine()",
                # Convert.ToSingle() - конвертує рядок у float32
                "    call float32 [mscorlib]System.Convert::ToSingle(string)"
            ])

    def _get_label_before(self, index):
        """
        Отримує мітку, що знаходиться перед поточною інструкцією

        Args:
            index: індекс поточної інструкції в постфікс-коді

        Returns:
            str: ім'я мітки або "unknown_label"
        """
        # Перевіряємо чи є попередній елемент
        if index > 0:
            # Беремо попередній елемент з постфікс-коду
            prev_item = self.postfix_code[index - 1]
            # Перевіряємо чи це мітка (починається з 'm' і містить цифри)
            if isinstance(prev_item, str) and prev_item.startswith('m') and prev_item[1:].isdigit():
                return prev_item
        # Якщо мітки не знайдено, повертаємо заглушку
        return "unknown_label"

    def _generate_print_instruction(self):
        """Генерує інструкції для виведення значення на екран"""
        # Простий підхід: виводимо як object (працює для всіх типів)
        self.cil_code.extend([
            # box = упакувати значення в об'єкт (boxing)
            # System.Single = float32 в .NET
            "    box [mscorlib]System.Single",
            # Console.WriteLine(object) - вивести об'єкт
            "    call void [mscorlib]System.Console::WriteLine(object)"
        ])

    def _is_number(self, s):
        """
        Перевіряє чи є рядок числом

        Args:
            s: рядок для перевірки

        Returns:
            bool: True якщо s - число, False інакше
        """
        try:
            # Спроба конвертувати в float
            float(s)
            return True
        except:
            # Якщо конвертація не вдалася - це не число
            return False

    def save_to_file(self, filename):
        """
        Зберігає згенерований CIL-код у файл

        Args:
            filename: ім'я файлу для збереження (зазвичай .il)

        Returns:
            str: згенерований CIL-код
        """
        # Генерація коду (якщо ще не згенерований)
        cil_code = self.generate()
        # Відкриваємо файл для запису з кодуванням UTF-8
        with open(filename, 'w', encoding='utf-8') as f:
            # Записуємо код у файл
            f.write(cil_code)
        # Виводимо повідомлення про успішне збереження
        print(f"✓ CIL-код збережено у файл: {filename}")
        # Повертаємо згенерований код
        return cil_code


def postfix_to_cil(postfix_code, variable_table, assembly_name="test1", output_file=None):
    """
    Конвертує постфікс-код у CIL

    Args:
        postfix_code: список інструкцій у постфіксній нотації
        variable_table: таблиця змінних
        assembly_name: ім'я збірки
        output_file: файл для збереження (якщо None, використовується assembly_name.il)

    Returns:
        str: згенерований CIL-код
    """
    # Створюємо генератор
    generator = CILGenerator(postfix_code, variable_table, assembly_name)

    # Якщо не вказано ім'я файлу, використовуємо стандартне
    if output_file is None:
        output_file = f"{assembly_name}.il"

    # Генеруємо і зберігаємо CIL-код
    cil_code = generator.save_to_file(output_file)
    # Повертаємо згенерований код
    return cil_code
