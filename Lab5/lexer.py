"""
Лексичний аналізатор для мови RSimple
Реалізований як скінченний автомат (Finite State Machine)
"""

# ========== ТАБЛИЦЯ ТОКЕНІВ ==========
# Ключові слова, оператори та розділювачі мови RSimple
# Формат: 'лексема': 'тип_токена'
tokenTable = {
    # Ключові слова керування потоком
    'if': 'keyword',        # Умовний оператор
    'else': 'keyword',      # Альтернатива умовного оператора
    'while': 'keyword',     # Оператор циклу
    'function': 'keyword',  # Оголошення функції (зарезервовано)

    # Ключові слова введення-виведення
    'print': 'keyword',     # Вивід на екран
    'scan': 'keyword',      # Введення з клавіатури

    # Булеві константи
    'TRUE': 'boolval',      # Істина (логічна константа)
    'FALSE': 'boolval',     # Хибність (логічна константа)

    # Оператори присвоювання
    '<-': 'assign_op',      # Присвоювання (стиль R)
    '=': 'assign_op',       # Присвоювання (стандартний)

    # Оператори додавання та віднімання
    '+': 'add_op',          # Додавання
    '-': 'add_op',          # Віднімання (або унарний мінус)

    # Оператори множення та ділення
    '*': 'mult_op',         # Множення
    '/': 'mult_op',         # Ділення

    # Оператор степеня
    '^': 'power_op',        # Піднесення до степеня

    # Оператори відношення (порівняння)
    '<': 'rel_op',          # Менше
    '<=': 'rel_op',         # Менше або дорівнює
    '==': 'rel_op',         # Дорівнює
    '>=': 'rel_op',         # Більше або дорівнює
    '>': 'rel_op',          # Більше
    '!=': 'rel_op',         # Не дорівнює

    # Дужки (круглі та фігурні)
    '(': 'brackets_op',     # Відкриваюча кругла дужка
    ')': 'brackets_op',     # Закриваюча кругла дужка
    '{': 'brackets_op',     # Відкриваюча фігурна дужка (блок)
    '}': 'brackets_op',     # Закриваюча фігурна дужка (блок)

    # Розділювачі
    ',': 'punct'            # Кома (розділення аргументів)
}

# ========== ТАБЛИЦЯ ВІДПОВІДНОСТІ СТАНІВ ДО ТИПІВ ТОКЕНІВ ==========
# Визначає який тип токена отримується у фінальному стані
tokStateTable = {
    2: 'id',        # Стан 2 → ідентифікатор (змінна)
    6: 'realnum',   # Стан 6 → дійсне число (з крапкою)
    9: 'intnum'     # Стан 9 → ціле число
}

# ========== ТАБЛИЦЯ ПЕРЕХОДІВ СТАНІВ (State Transition Function) ==========
# Визначає переходи між станами автомата
# Формат: (поточний_стан, клас_символу): новий_стан
stf = {
    # Розпізнавання ідентифікаторів (починаються з літери)
    (0, 'Letter'): 1,   # Початок ідентифікатора
    (1, 'Letter'): 1,   # Продовження літерою
    (1, 'Digit'): 1,    # Продовження цифрою
    (1, '_'): 1,        # Продовження підкресленням
    (1, 'dot'): 1,      # Продовження крапкою (для складених імен)
    (1, 'other'): 2,    # Кінець ідентифікатора (фінальний стан)

    # Розпізнавання цілих чисел (починаються з цифри)
    (0, 'Digit'): 4,    # Початок числа
    (4, 'Digit'): 4,    # Продовження цифрою (накопичення цілої частини)

    # Розпізнавання дробових чисел (з крапкою)
    (4, 'dot'): 5,      # Перехід до дробової частини
    (5, 'Digit'): 5,    # Накопичення дробової частини
    (5, 'other'): 6,    # Кінець дробового числа (фінальний стан)

    # Кінець цілого числа
    (4, 'other'): 9,    # Кінець цілого числа (фінальний стан)

    # Дробове число, що починається з крапки (наприклад, .5)
    (0, 'dot'): 3,      # Крапка на початку
    (3, 'Digit'): 5,    # Після крапки йде цифра

    # Розпізнавання оператора '<' або '<-' або '<='
    (0, '<'): 11,       # Зустріли '<'
    (11, '-'): 12,      # Зустріли '<-' (присвоювання) - фінальний стан
    (11, '='): 13,      # Зустріли '<=' (менше-дорівнює) - фінальний стан
    (11, 'other'): 14,  # Просто '<' (менше) - фінальний стан

    # Розпізнавання оператора '>' або '>='
    (0, '>'): 15,       # Зустріли '>'
    (15, '='): 16,      # Зустріли '>=' (більше-дорівнює) - фінальний стан
    (15, 'other'): 17,  # Просто '>' (більше) - фінальний стан

    # Розпізнавання оператора '=' або '=='
    (0, '='): 18,       # Зустріли '='
    (18, '='): 19,      # Зустріли '==' (дорівнює) - фінальний стан
    (18, 'other'): 102, # Просто '=' після нього має йти '=' (помилка!)

    # Розпізнавання оператора '!='
    (0, '!'): 20,       # Зустріли '!'
    (20, '='): 21,      # Зустріли '!=' (не дорівнює) - фінальний стан
    (20, 'other'): 102, # Просто '!' неприпустимо (помилка!)

    # Розпізнавання коментарів (починаються з '#')
    (0, '#'): 22,       # Початок коментаря
    (22, 'eol'): 23,    # Кінець рядка = кінець коментаря - фінальний стан
    (22, 'other'): 22,  # Будь-який символ в коментарі ігнорується

    # Пропуск пробілів та переходів на новий рядок
    (0, 'ws'): 0,       # Пробіл/табуляція → залишаємось у початковому стані
    (0, 'eol'): 23,     # Перехід на новий рядок - фінальний стан

    # Однозначні оператори (розпізнаються одразу)
    (0, '+'): 24,       # Оператор '+'
    (0, '-'): 24,       # Оператор '-'
    (0, '*'): 24,       # Оператор '*'
    (0, '/'): 24,       # Оператор '/'
    (0, '^'): 24,       # Оператор '^'
    (0, '('): 24,       # Відкриваюча дужка '('
    (0, ')'): 24,       # Закриваюча дужка ')'
    (0, '{'): 24,       # Відкриваюча фігурна дужка '{'
    (0, '}'): 24,       # Закриваюча фігурна дужка '}'
    (0, ','): 24,       # Кома ','

    # Обробка невідомих символів
    (0, 'other'): 101   # Невідомий символ - помилка!
}

# ========== КОНСТАНТИ АВТОМАТА ==========

# Початковий стан автомата
initState = 0

# Множина фінальних станів (у них завершується розпізнавання токена)
F = {2, 6, 9, 12, 13, 14, 16, 17, 19, 21, 23, 24, 101, 102}

# Фінальні стани з поверненням символу (Fstar)
# У цих станах потрібно повернути останній символ назад,
# бо він належить наступному токену
Fstar = {2, 6, 9, 14, 17}

# Стани помилок
Ferror = {101, 102}


class Lexer:
    """
    Лексичний аналізатор (токенізатор) для мови RSimple
    Реалізований як детермінований скінченний автомат
    """

    def __init__(self):
        """Ініціалізація лексера з порожніми таблицями"""
        # Таблиця ідентифікаторів (змінних)
        # Формат: {ім'я: індекс}
        self.tableOfId = {}

        # Таблиця констант (чисел)
        # Формат: {значення: (тип, індекс)}
        self.tableOfConst = {}

        # Таблиця символів (токенів)
        # Формат: {номер: (рядок, лексема, тип, індекс)}
        self.tableOfSymb = {}

        # Вхідний код програми (рядок)
        self.sourceCode = ''

        # Довжина вхідного коду
        self.lenCode = 0

        # Номер поточного рядка у вхідному коді
        self.numLine = 1

        # Номер поточного символу у вхідному коді
        self.numChar = -1

        # Поточний символ, що обробляється
        self.char = ''

        # Поточна лексема (накопичується посимвольно)
        self.lexeme = ''

        # Поточний стан скінченного автомата
        self.state = initState

        # Прапорець успішності аналізу (True/False/None)
        self.success = None

    def classOfChar(self, char):
        """
        Визначає клас символу для таблиці переходів

        Args:
            char: символ для класифікації

        Returns:
            str: клас символу ('Letter', 'Digit', 'ws', 'eol', '+', '-', тощо)
        """
        # Перевірка на крапку (для дробових чисел)
        if char == '.':
            return "dot"
        # Перевірка на літеру (англійські, великі та малі)
        elif char in 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ':
            return "Letter"
        # Перевірка на цифру
        elif char in "0123456789":
            return "Digit"
        # Перевірка на пробіл або табуляцію (whitespace)
        elif char in " \t":
            return "ws"
        # Перевірка на кінець рядка (end of line)
        elif char in "\n\r":
            return "eol"
        # Перевірка на підкреслення (для ідентифікаторів)
        elif char == '_':
            return "_"
        # Перевірка на символ коментаря
        elif char == '#':
            return "#"
        # Оператори та розділювачі (кожен має свій клас)
        elif char in "<>=!+-*/^(){},:;":
            return char
        # Все інше - невідомий символ
        else:
            return 'other'

    def nextChar(self):
        """
        Повертає наступний символ з вхідного коду

        Returns:
            str: наступний символ або '' якщо кінець коду
        """
        # Збільшуємо лічильник символів
        self.numChar += 1
        # Перевіряємо чи не досягли кінця коду
        if self.numChar < self.lenCode:
            # Повертаємо символ на поточній позиції
            return self.sourceCode[self.numChar]
        # Якщо кінець коду - повертаємо порожній рядок
        return ''

    def putCharBack(self):
        """
        Повертає символ назад (для станів з Fstar)
        Використовується коли останній символ належить наступному токену
        """
        # Зменшуємо лічильник на 1 (йдемо на крок назад)
        self.numChar -= 1

    def nextState(self, state, classCh):
        """
        Визначає наступний стан автомата за поточним станом та класом символу

        Args:
            state: поточний стан автомата
            classCh: клас поточного символу

        Returns:
            int: наступний стан автомата
        """
        try:
            # Шукаємо перехід у таблиці переходів
            return stf[(state, classCh)]
        except KeyError:
            # Якщо не знайдено точного переходу, шукаємо перехід для 'other'
            # Якщо і його немає - залишаємось у поточному стані
            return stf.get((state, 'other'), state)

    def is_final(self, state):
        """
        Перевіряє, чи є стан фінальним

        Args:
            state: стан для перевірки

        Returns:
            bool: True якщо стан фінальний, False інакше
        """
        # Перевіряємо чи стан входить у множину фінальних станів
        return state in F

    def getToken(self, state, lexeme):
        """
        Визначає тип токена за фінальним станом і лексемою

        Args:
            state: фінальний стан автомата
            lexeme: розпізнана лексема

        Returns:
            str: тип токена ('id', 'keyword', 'intnum', 'rel_op', тощо)
        """
        # Для стану 2 (ідентифікатор) перевіряємо чи це ключове слово
        if state == 2:
            # Шукаємо в таблиці ключових слів
            # Якщо знайдено - повертаємо тип з таблиці
            # Якщо не знайдено - це звичайний ідентифікатор ('id')
            return tokenTable.get(lexeme, 'id')
        # Для станів 6 і 9 (числа) використовуємо tokStateTable
        elif state in tokStateTable:
            return tokStateTable[state]
        # Для станів 14 і 17 (оператори < і >)
        elif state in (14, 17):
            return 'rel_op'
        # Для інших станів шукаємо лексему в загальній таблиці
        elif lexeme in tokenTable:
            return tokenTable[lexeme]
        # Якщо нічого не підійшло - невідомий токен
        return 'unknown'

    def indexIdConst(self, state, lexeme):
        """
        Додає ідентифікатор або константу до відповідної таблиці

        Args:
            state: фінальний стан (2 для id, 6 або 9 для чисел)
            lexeme: розпізнана лексема

        Returns:
            int або '': індекс у таблиці або порожній рядок
        """
        # Обробка ідентифікаторів (стан 2)
        if state == 2:
            # Визначаємо тип токена
            token = self.getToken(state, lexeme)
            # Якщо це справді ідентифікатор (не ключове слово)
            if token == 'id':
                # Перевіряємо чи вже є в таблиці
                if lexeme not in self.tableOfId:
                    # Додаємо новий ідентифікатор з наступним індексом
                    self.tableOfId[lexeme] = len(self.tableOfId) + 1
                # Повертаємо індекс ідентифікатора
                return self.tableOfId[lexeme]
            else:
                # Це ключове слово - індекс не потрібен
                return ''
        # Обробка числових констант (стани 6 і 9)
        elif state in (6, 9):
            # Перевіряємо чи константа вже є в таблиці
            if lexeme not in self.tableOfConst:
                # Визначаємо тип числа (intnum або realnum)
                token = tokStateTable[state]
                # Додаємо константу: значення → (тип, індекс)
                self.tableOfConst[lexeme] = (token, len(self.tableOfConst) + 1)
            # Повертаємо індекс константи (другий елемент кортежу)
            return self.tableOfConst[lexeme][1]
        # Інші випадки - індекс не потрібен
        return ''

    def fail(self):
        """Обробляє помилки лексичного аналізу"""
        # Помилка 101: невідомий символ
        if self.state == 101:
            print(f'!!! Lexer: неочікуваний символ "{self.char}" у рядку {self.numLine}')
        # Помилка 102: неповний оператор (наприклад, '!' без '=')
        elif self.state == 102:
            print(f'!!! Lexer: неповний оператор "{self.lexeme}{self.char}" у рядку {self.numLine}')

    def processing(self):
        """Обробляє розпізнану лексему у фінальному стані"""
        # Стан 23: кінець рядка або коментар
        if self.state == 23:
            # Збільшуємо номер рядка
            self.numLine += 1
            # Скидаємо стан до початкового
            self.state = initState
            # Очищаємо поточну лексему
            self.lexeme = ''
            # Виходимо з функції (токен не створюється)
            return

        # Стани 2, 6, 9: ідентифікатор або число
        if self.state in (2, 6, 9):
            # Визначаємо тип токена
            token = self.getToken(self.state, self.lexeme)
            # Якщо це ідентифікатор або число
            if token == 'id' or token in ('intnum', 'realnum'):
                # Додаємо до відповідної таблиці та отримуємо індекс
                index = self.indexIdConst(self.state, self.lexeme)
                # Додаємо токен до таблиці символів
                # Формат: (номер_рядка, лексема, тип, індекс)
                self.tableOfSymb[len(self.tableOfSymb) + 1] = (
                    self.numLine, self.lexeme, token, index
                )
            else:
                # Це ключове слово або булева константа
                # Додаємо без індексу (індекс = '')
                self.tableOfSymb[len(self.tableOfSymb) + 1] = (
                    self.numLine, self.lexeme, token, ''
                )
            # Очищаємо лексему для наступного токена
            self.lexeme = ''
            # Повертаємо символ назад (він належить наступному токену)
            self.putCharBack()
            # Повертаємось до початкового стану
            self.state = initState

        # Стани 12, 13, 14, 16, 17, 19, 21, 24: оператори та розділювачі
        elif self.state in (12, 13, 14, 16, 17, 19, 21, 24):
            # Додаємо поточний символ до лексеми
            self.lexeme += self.char
            # Визначаємо тип токена
            token = self.getToken(self.state, self.lexeme)
            # Додаємо токен до таблиці символів
            # strip() видаляє зайві пробіли з лексеми
            self.tableOfSymb[len(self.tableOfSymb) + 1] = (
                self.numLine, self.lexeme.strip(), token, ''
            )
            # Очищаємо лексему
            self.lexeme = ''
            # Якщо стан вимагає повернення символу
            if self.state in Fstar:
                self.putCharBack()
            # Повертаємось до початкового стану
            self.state = initState

        # Стани помилок (101, 102)
        elif self.state in Ferror:
            # Виводимо повідомлення про помилку
            self.fail()
            # Аварійно завершуємо програму з кодом помилки
            raise SystemExit(self.state)

    def analyze(self, source_code):
        """
        Виконує лексичний аналіз вхідного коду

        Args:
            source_code: текст програми для аналізу

        Returns:
            bool: True якщо аналіз успішний, False якщо є помилки
        """
        # Додаємо пробіл в кінець коду (для коректного завершення)
        self.sourceCode = source_code + ' '
        # Зберігаємо довжину коду (мінус один символ)
        self.lenCode = len(self.sourceCode) - 1

        try:
            # Головний цикл аналізу: проходимо по всіх символах
            while self.numChar < self.lenCode - 1:
                # Отримуємо наступний символ
                self.char = self.nextChar()
                # Визначаємо клас символу
                classCh = self.classOfChar(self.char)
                # Визначаємо наступний стан автомата
                self.state = self.nextState(self.state, classCh)

                # Якщо досягли фінального стану
                if self.is_final(self.state):
                    # Обробляємо розпізнану лексему
                    self.processing()
                # Якщо повернулись до початкового стану
                elif self.state == initState:
                    # Очищаємо лексему (новий токен почнеться з наступного символу)
                    self.lexeme = ''
                else:
                    # Накопичуємо символ у поточну лексему
                    self.lexeme += self.char

            # Аналіз завершено успішно
            print('✓ Lexer: Лексичний аналіз завершено успішно\n')
            # Встановлюємо прапорець успіху
            self.success = True
            return True

        except SystemExit as e:
            # Відловлюємо помилки лексичного аналізу
            print(f'✗ Lexer: Програма аварійно завершена з кодом {e.code}')
            # Встановлюємо прапорець невдачі
            self.success = False
            return False

    def reset(self):
        """Скидає стан лексера до початкового (для повторного аналізу)"""
        # Очищаємо таблицю ідентифікаторів
        self.tableOfId = {}
        # Очищаємо таблицю констант
        self.tableOfConst = {}
        # Очищаємо таблицю символів
        self.tableOfSymb = {}
        # Очищаємо вхідний код
        self.sourceCode = ''
        # Скидаємо довжину коду
        self.lenCode = 0
        # Скидаємо номер рядка
        self.numLine = 1
        # Скидаємо номер символу
        self.numChar = -1
        # Очищаємо поточний символ
        self.char = ''
        # Очищаємо поточну лексему
        self.lexeme = ''
        # Повертаємось до початкового стану автомата
        self.state = initState
        # Скидаємо прапорець успіху
        self.success = None

    def get_tables(self):
        """
        Повертає всі таблиці лексера (для використання парсером)

        Returns:
            dict: словник з трьома таблицями
        """
        return {
            # Таблиця всіх розпізнаних токенів
            'symbols': self.tableOfSymb,
            # Таблиця унікальних ідентифікаторів
            'identifiers': self.tableOfId,
            # Таблиця унікальних констант
            'constants': self.tableOfConst
        }
