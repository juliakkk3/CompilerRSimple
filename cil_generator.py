"""
CIL code generator for the CLR virtual machine
"""

class CILGenerator:
    """CIL code generator from postfix notation"""

    def __init__(self, postfix_code, variable_table, assembly_name="test1"):
        """
        Generator initialization

        Args:
            postfix_code: list of postfix instructions
            variable_table: variable table {ident: (index, type, initialized)}
            assembly_name: assembly name (without extension)
        """
        self.postfix_code = postfix_code
        self.variable_table = variable_table
        self.assembly_name = assembly_name
        self.cil_code = []
        self.label_mapping = {}  # Mapping postfix labels to CIL positions

    def generate(self):
        """Generates the complete CIL code"""
        self._generate_header()
        self._generate_class_definition()
        self._generate_main_method()
        return '\n'.join(self.cil_code)

    def _generate_header(self):
        """Generates the .il file header"""
        self.cil_code.extend([
            "// Generated by RSimple Compiler",
            "",
            ".assembly extern mscorlib",
            "{",
            "  .publickeytoken = (B7 7A 5C 56 19 34 E0 89 )",
            "  .ver 4:0:0:0",
            "}",
            "",
            f".assembly {self.assembly_name}",
            "{",
            "  .hash algorithm 0x00008004",
            "  .ver 0:0:0:0",
            "}",
            f".module {self.assembly_name}.exe",
            ""
        ])

    def _generate_class_definition(self):
        """Generates the Program class definition"""
        self.cil_code.extend([
            ".class private auto ansi beforefieldinit Program",
            "  extends [mscorlib]System.Object",
            "{"
        ])

    def _generate_main_method(self):
        """Generates the Main method with CIL instructions"""
        self.cil_code.extend([
            "  .method private hidebysig static void Main(string[] args) cil managed",
            "  {",
        ])

        # Generation of local variables
        self._generate_locals()

        self.cil_code.extend([
            "    .entrypoint",
            "    .maxstack 8",
            ""
        ])

        # Generation of instructions from postfix code
        self._generate_instructions()

        self.cil_code.extend([
            "    ret",
            "  }",
            "}"
        ])

    def _generate_locals(self):
        """Generates local variable declarations"""
        if not self.variable_table:
            return

        self.cil_code.append("    .locals init (")

        # Sort variables by index
        sorted_vars = sorted(self.variable_table.items(),
                           key=lambda x: x[1][0])

        for i, (ident, (index, var_type, _)) in enumerate(sorted_vars):
            cil_type = self._convert_type_to_cil(var_type)
            # If the variable name is a reserved CIL word, add a prefix
            safe_ident = self._make_safe_identifier(ident)
            line = f"      [{index-1}] {cil_type} {safe_ident}"

            if i < len(sorted_vars) - 1:
                line += ","

            self.cil_code.append(line)

        self.cil_code.append("    )")

    def _make_safe_identifier(self, ident):
        """Makes an identifier safe for CIL (avoids keywords)"""
        # List of reserved CIL and .NET keywords
        cil_keywords = {
            # CIL instructions
            'add', 'and', 'box', 'br', 'break', 'call', 'callvirt', 'ceq', 'cgt', 'clt',
            'conv', 'div', 'dup', 'ldarg', 'ldloc', 'ldstr', 'ldc', 'mul', 'neg', 'newarr',
            'not', 'or', 'pop', 'ret', 'starg', 'stloc', 'sub', 'throw', 'xor',
            # Declarations and modifiers
            'class', 'method', 'field', 'property', 'event', 'interface', 'enum',
            'value', 'object', 'string', 'void', 'bool', 'char', 'int8', 'int16',
            'int32', 'int64', 'float32', 'float64', 'unsigned', 'native',
            'final', 'virtual', 'abstract', 'static', 'public', 'private', 'protected',
            'internal', 'extern', 'override', 'sealed', 'new', 'base', 'this',
            # Other .NET keywords
            'any', 'as', 'assembly', 'at', 'auto', 'beforefieldinit', 'cil',
            'default', 'extends', 'implements', 'init', 'instance', 'literal',
            'managed', 'module', 'namespace', 'nested', 'pinned', 'request',
            'runtime', 'sequential', 'serializable', 'specialname', 'unmanaged',
            'valuetype', 'vararg'
        }

        # If the identifier is a keyword, add the prefix 'var_'
        if ident.lower() in cil_keywords:
            return f"var_{ident}"
        return ident

    def _convert_type_to_cil(self, var_type):
        """Converts an RSimple type to a CIL type"""
        type_mapping = {
            'numeric': 'float32',
            'logical': 'int32',  # bool in CIL is represented as int32
            'int': 'int32',
            'float': 'float32'
        }
        return type_mapping.get(var_type, 'float32')

    def _generate_instructions(self):
        """Generates CIL instructions from postfix code"""
        # First pass: collect label positions

        self._collect_labels()

        # Second pass: generate instructions
        i = 0
        while i < len(self.postfix_code):
            item = self.postfix_code[i]

            if isinstance(item, str):
                if item.endswith(':'):
                    # Label
                    label_name = item[:-1]
                    self.cil_code.append(f"    {label_name}:")
                else:
                    # Pass the index for handling JF/JMP
                    self._generate_instruction(item, i)

            i += 1

    def _collect_labels(self):
        """Collects information about labels (first pass)"""
        instruction_count = 0
        for item in self.postfix_code:
            if isinstance(item, str) and item.endswith(':'):
                label_name = item[:-1]
                self.label_mapping[label_name] = instruction_count
            else:
                instruction_count += 1

    def _generate_instruction(self, instr, index=0):
        """Generates a single CIL instruction"""

        # Numeric constants
        if self._is_number(instr):
            if '.' in instr:
                # Float
                self.cil_code.append(f"    ldc.r4 {instr}")
            else:
                # Int - load as int, then convert to float
                value = int(instr)
                # Optimization for small numbers
                if -1 <= value <= 8:
                    self.cil_code.append(f"    ldc.i4.{value}" if value >= 0 else f"    ldc.i4.m1")
                elif -128 <= value <= 127:
                    self.cil_code.append(f"    ldc.i4.s {value}")
                else:
                    self.cil_code.append(f"    ldc.i4 {value}")
                # IMPORTANT: convert int32 → float32
                self.cil_code.append(f"    conv.r4")

        # Boolean constants
        elif instr in ('TRUE', 'FALSE'):
            value = '1' if instr == 'TRUE' else '0'
            self.cil_code.append(f"    ldc.i4.{value}")

        # Variables (loading value)
        elif instr in self.variable_table:
            var_index = self.variable_table[instr][0] - 1
            var_type = self.variable_table[instr][1]
            safe_ident = self._make_safe_identifier(instr)

            # Use short forms for ldloc
            if var_index <= 3:
                self.cil_code.append(f"    ldloc.{var_index}")
            else:
                self.cil_code.append(f"    ldloc {var_index}")

        # Labels for jumps
        elif instr.startswith('m') and instr[1:].isdigit():
            # This is a label for JMP/JF - do not generate code
            pass

        elif instr.startswith('='):
            var_name = instr[1:]
            var_index = self.variable_table[var_name][0] - 1
            var_type = self.variable_table[var_name][1]

            if var_index <= 3:
                self.cil_code.append(f"    stloc.{var_index}")
            else:
                self.cil_code.append(f"    stloc {var_index}")

        # Arithmetic operations
        elif instr == '+':
            self.cil_code.append("    add")
        elif instr == '-':
            self.cil_code.append("    sub")
        elif instr == '*':
            self.cil_code.append("    mul")
        elif instr == '/':
            self.cil_code.append("    div")
        elif instr == '^':
            # For exponentiation, use Math.Pow(base, exponent)
            # On the stack: [base(float32), exponent(float32)]
            # Math.Pow requires: (float64, float64)
            # CLR automatically converts float32 -> float64 on call!
            self.cil_code.extend([
                "    call float64 [mscorlib]System.Math::Pow(float64, float64)",
                "    conv.r4"   # Convert the result back to float32
            ])
        elif instr == 'unary-':
            self.cil_code.append("    neg")

        # Comparison operators
        elif instr == '<':
            self.cil_code.append("    clt")
        elif instr == '>':
            self.cil_code.append("    cgt")
        elif instr == '<=':
            self.cil_code.extend([
                "    cgt",      # a > b
                "    ldc.i4.0",
                "    ceq"       # (a > b) == 0, i.e., a <= b
            ])
        elif instr == '>=':
            self.cil_code.extend([
                "    clt",      # a < b
                "    ldc.i4.0",
                "    ceq"       # (a < b) == 0, i.e., a >= b
            ])
        elif instr == '==':
            self.cil_code.append("    ceq")
        elif instr == '!=':
            self.cil_code.extend([
                "    ceq",      # a == b
                "    ldc.i4.0",
                "    ceq"       # (a == b) == 0, i.e., a != b
            ])

        # Jumps
        elif instr == 'JF':
            label = self._get_label_before(index)
            self.cil_code.append(f"    brfalse {label}")

        elif instr == 'JMP':
            label = self._get_label_before(index)
            self.cil_code.append(f"    br {label}")

        # Input-output
        elif instr == 'print':
            self._generate_print_instruction()

        elif instr == 'scan':
            self.cil_code.extend([
                "    call string [mscorlib]System.Console::ReadLine()",
                "    call float32 [mscorlib]System.Convert::ToSingle(string)"
            ])

    def _get_label_before(self, index):
        """Gets the label preceding the current instruction"""
        if index > 0:
            prev_item = self.postfix_code[index - 1]
            if isinstance(prev_item, str) and prev_item.startswith('m') and prev_item[1:].isdigit():
                return prev_item
        return "unknown_label"

    def _generate_print_instruction(self):
        """Generates instructions for output"""
        # Simple approach: output as object (works for all types)
        self.cil_code.extend([
            "    box [mscorlib]System.Single",  # Box for output
            "    call void [mscorlib]System.Console::WriteLine(object)"
        ])

    def _is_number(self, s):
        """Checks if a string is a number"""
        try:
            float(s)
            return True
        except:
            return False

    def save_to_file(self, filename):
        """Saves the CIL code to a file"""
        cil_code = self.generate()
        with open(filename, 'w', encoding='utf-8') as f:
            f.write(cil_code)
        print(f"✓ # CIL code saved to file: {filename}")
        return cil_code


def postfix_to_cil(postfix_code, variable_table, assembly_name="test1", output_file=None):
    """
    Converts postfix code to CIL

    Args:
        postfix_code: list of postfix instructions
        variable_table: variable table
        assembly_name: assembly name
        output_file: file to save to (if None, defaults to assembly_name.il)

    Returns:
        str: generated CIL code
    """
    generator = CILGenerator(postfix_code, variable_table, assembly_name)

    if output_file is None:
        output_file = f"{assembly_name}.il"

    cil_code = generator.save_to_file(output_file)
    return cil_code
